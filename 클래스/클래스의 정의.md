# 구조체(Structure)란?
여러 데이터를 구조화 하여 담는 그릇.

# 클래스(Class)란?
구조체의 상위 호환 개념으로 데이터를 담고, 그 대상들이 하는 일을 정리해놓은 그릇.

(C++ 에서는 둘의 차이가 거의 존재하지 않는다. ex. default 속성)

# 객체지향 프로그래밍(OOP)

프로그램은 절차 순으로 진행된다. 이러한 프로그램을 역할에 따라 분리하여 여러 흐름들로 나누는 프로그래밍 기법.

역할에 따라 구분한다는 것은 각 객체의 상태와 행동을 하나의 Class에 담아서 표현함을 의미한다.
  
### 객체 지향 프로그래밍의 특징

  1) 추상화(abstraction) = 클래스, 함수의 코드를 보지 않고 이해하지 않아도 이를 이용할 수 있다.
  2) 캡슐화(encapsulation) = 데이터를 담아서 한 번에 관리할 수 있다.
  3) 정보은닉(data hiding) = 데이터를 감출 수 있다.(public, private, protect의 사용이 자유롭다.)
  4) 상속성(inheritance) = 클래스의 모든 정보를 사용하는 클래스를 만들 수 있다.
  5) 다형성(polymorphism) = 클래스를 다양한 형태로 구현할 수 있고 동적으로 연결하는 것이 가능하다.
  
### 객체지향 프로그래밍의 장점

  1) 역할을 나누어 표현하므로 가독성 높은 코드의 완성
  2) 각 각의 코드들의 의존성이 낮아져서 프로그램의 수정이 편리하다.
  3) 추상화를 통해 프로그램의 복잡도를 낮춘다.
  4) 개발자, 사용자 간의 데이터를 감추어 보안성을 올릴 수 있다.
  5) 상속을 통해 코드의 반복을 줄일 수 있다.
  6) 다형성을 통해 유연한 개발이 가능하다.

#### 정보은닉

`데이터 및 함수를 감추거나 드러낼 수 있다.`

클래스 내부에서 private, public, protected를 사용할 수 있다.<br>
=> 해당 선언 이후 부터는 위의 속성을 따라서 정보를 처리한다.(default = private)

클래스 선언 시에 상속을 이용하는 경우 상속 속성을 정할 수 있다.<br>
=> 클래스의 기본 타입을 어떻게 할 지를 정할 수 있다.(default는 public)


### this 포인터

`클래스를 이용해 생성된 인스턴스 자신을 가르키는 포인터`

클래스의 멤버 함수에서 마음껏 사용할 수 있으면 자신의 값에 접근할 때 사용한다.

단, 정적 멤버 함수에서는 사용할 수 없습니다. <br>
ex) void print() const;

### static 변수 선언

`하나의 클래스로 구현된 모든 인스턴스에서 공유하는 변수`

static를 통해 선언

### 생성자, 소멸자

클래스를 만들게 되면 해당 클래스의 생성과 소멸 시에 행동을 설정해주어야한다.

소멸자는 메모리 누수를 방지하기 위해 pointer를 통해 heap에 동적 할당한 data를 삭제해 주어야 한다.

포인터 파트에서 언급했던 이미 삭제한 포인터를 삭제하려고 하면 문제가 발생하는 현상을 잘 유의해야 한다.

따라서, 멤버 변수로 포인터를 사용하고, 이를 삭제하게 된다면(해당 클래스의 인스턴스를 copy하고 소멸 시킨 경우) 에러가 발생한다.

이에 대한 해결책으로 복사 생성자가 존재한다.

포인터를 복사하는 것이 아니라, 포인터가 가르키는 data 자체를 복사해서 복사하는 대상이 복사된 새로운 data를 가르키도록 한다.

### 같은 함수 이름을 가지는 함수를 사용하는 방법.

사용자 입장에서는 똑같은 역할을 수행하는데 프로그램 안에서의 logic이 다른 경우 많이 사용한다.

*연산자도 함수이다.(+, -, /, * 등)

#### 오버로딩

함수의 파라미터를 바꾸어(갯수, 변수 타입) 같은 함수 이름을 이용하여 다른 기능을 구현하는 것


#### friend 

`속하지 않는 대상을 속한 것처럼 표현하는 방법`

```
1) 일반 함수를 클래스의 멤버 함수로 만들어주는 방법.
2) 클래스 자체를 클래스의 프렌드로 만드는 방법
```

이를 통해 다른 클래스 or 일반 함수에서도 클래스의 private 멤버 변수에 접근할 수 있다.

#### 오버라이딩

추상화된 함수를 상속한 클래스 내에서 바꾸어주는 방식이다.
